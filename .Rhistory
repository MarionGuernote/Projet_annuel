} else if (eq[[i]]$text[1] == eq[[i]]$text[3]) {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
} else {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[3:(dim(eq[[i]])[1])], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
}
print(v2)
}
v = rbind(v1, v2)
nodes = as.vector(t(v))
library(RCy3)
cytoscapePing ()
cytoscapeVersionInfo ()
style.name = "myStyle"
defaults <- list(NODE_SHAPE="diamond",
NODE_SIZE=30,
EDGE_TRANSPARENCY=120)
nodes = data.frame(id = unique(nodes),col='#ff0000')
edges = data.frame(target = v[, 1], source = v[, 2], attr = v[, 3], interaction = c("interacts"), weight = 1)
createNetworkFromDataFrames(nodes, edges, title = "my first network", collection = "DataFrame Example")
Script.Name = "test.R"
rm(list = ls(all = TRUE))  # broom variables
gc()  # garbage collector
cat("\f")  #clear console
# LIBRARIES ---------------------------------------------------------------
setwd("D:/Fac/Master1/S2/Projet_annuel")
library(formatR)
library(RCy3)
formatR::tidy_file("./final.R")
p_dat = parse("./final.R")
#parse script
parsed = getParseData(p_dat)
#removing unwanted/empty/unknown lines
parsed = parsed[-c(which(parsed$token == "expr")), ]
parsed = parsed[-c(which(parsed$token %in% c("expr", "equal_assign", "forcond"))), ]
xy.list <- split(parsed, f = parsed$line1)
#extracting comments
xy.list.comments = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT")]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT") == F]
#extracting packages imports
xy.list.packages = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library")]
packages = as.character(lapply(lapply(xy.list.packages, `[[`, 9), `[[`, 3))
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library") == F]
l.packages=rep("library",length(packages))
packages=cbind(l.packages,packages)
#excluding system commands
to_remove = c("rm", "cat", "gc", "setwd")
xy.list.rm = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove)]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove) == F]
#extracting equal assign lines of length 3 (something = some other thing)
tmp_ind = which(lengths(lapply(xy.list, `[[`, 7)) == 3)
ind_eq = which(lapply(lapply(xy.list[tmp_ind], `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
eq = xy.list[tmp_ind][ind_eq]
xy.list[tmp_ind[ind_eq]] <- NULL
v = c()
for (i in 1:length(eq)) {
v = rbind(v, c(eq[[i]]$text[c(1, 3)]))
}
# v[,1]=make.unique(v[,1])
v1 = matrix(v, nrow = length(make.unique(v))/2)
v1=rbind(v1,packages)
v1 = cbind(v1, rep("", dim(v1)[1]))
##### more complex lines length > 3
tmp_ind = which(lengths(lapply(xy.list, `[[`, 7)) > 3)
## we still look at lines where there is a =
ind_eq = which(lapply(lapply(xy.list[tmp_ind], `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
eq = xy.list[tmp_ind][ind_eq]
xy.list[tmp_ind[ind_eq]] <- NULL
c=1
v2 = c()
fun = c("read.table", "readRDS")
fun2 =c("data.frame")
for (i in 1:length(eq)) {
print(eq[[i]])
if (eq[[i]]$token[3] == "SYMBOL_FUNCTION_CALL") {
#token 5: because we look after something = something else (
#                               1         2 3              4
j = which(eq[[i]]$token[5:(dim(eq[[i]])[1] - 1)] == "SYMBOL")
f = which(eq[[i]]$token[5:(dim(eq[[i]])[1] - 1)] == "SYMBOL_FUNCTION_CALL")
#specific parsing for well known functions
if (eq[[i]]$text[3]%in%fun) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste("input.file.",c,sep=""), eq[[i]]$text[3]))
c=c+1
} else if (eq[[i]]$text[3]%in%fun2) {
if (length(j) > 0 &length(f) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), paste(eq[[i]]$text[3],eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][f],sep="+")))
} else {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)],collapse=""), eq[[i]]$text[3]))}
} else if (length(j) > 0 &length(f) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), paste(eq[[i]]$text[3],eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][f],sep="+")))
} else if (length(j) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), eq[[i]]$text[3]))
} else {
v2 = rbind(v2, c(eq[[i]]$text[1], eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)], eq[[i]]$text[3]))}
} else if (eq[[i]]$text[1] == eq[[i]]$text[3]) {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
} else {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[3:(dim(eq[[i]])[1])], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
}
print(v2)
}
v = rbind(v1, v2)
nodes = as.vector(t(v))
library(RCy3)
cytoscapePing ()
cytoscapeVersionInfo ()
style.name = "myStyle"
defaults <- list(NODE_SHAPE="diamond",
NODE_SIZE=30,
EDGE_TRANSPARENCY=120)
nodeLabels <- mapVisualProperty('node label','id','p')
nodeFills <- mapVisualProperty('node fill color','group','d',c("A","B"), c("#FF9900","#66AAAA"))
arrowShapes <- mapVisualProperty('Edge Target Arrow Shape','interaction','d',c("activates","inhibits","interacts"),c("Arrow","T","None"))
edgeWidth <- mapVisualProperty('edge width','weight','p')
createVisualStyle(style.name, defaults, list(nodeLabels,arrowShapes,edgeWidth))
setVisualStyle(style.name)
nodes = data.frame(id = unique(nodes),col='#ff0000')
edges = data.frame(target = v[, 1], source = v[, 2], attr = v[, 3], interaction = c("interacts"), weight = 1)
createNetworkFromDataFrames(nodes, edges, title = "my first network", collection = "DataFrame Example")
# setEdgeLabelBypass(edge.names = paste(edges$source, " (", edges$interaction, ") ", edges$target, sep = ""), new.labels = edges$attr)
setEdgeLabelMapping(table.column = "attr",style.name = 'default')
setEdgeTargetArrowShapeDefault(new.shape = "ARROW")
cytoscapePing ()
cytoscapeVersionInfo ()
style.name = "myStyle"
defaults <- list(NODE_SHAPE="ellipse",
NODE_SIZE=40,
EDGE_TRANSPARENCY=120)
nodeLabels <- mapVisualProperty('node label','id','p')
arrowShapes <- mapVisualProperty('Edge Target Arrow Shape','interaction','d',c("activates","inhibits","interacts"),c("Arrow","T","None"))
edgeWidth <- mapVisualProperty('edge width','weight','p')
control.points <- c (-3.0, 0.0, 3.0)
colors <-  c ('#5588DD', '#FFFFFF', '#DD8855')
setNodeColorMapping (column, control.points, colors)
colors <-  c ('#5588DD', '#FFFFFF', '#DD8855')
setNodeColorMapping (nodes, control.points, colors)
cytoscapePing ()
cytoscapeVersionInfo ()
style.name = "myStyle"
defaults <- list(NODE_SHAPE="ellipse",
NODE_SIZE=40,
EDGE_TRANSPARENCY=120)
nodeLabels <- mapVisualProperty('node label','id','p')
arrowShapes <- mapVisualProperty('Edge Target Arrow Shape','interaction','d',c("activates","inhibits","interacts"),c("Arrow","T","None"))
edgeWidth <- mapVisualProperty('edge width','weight','p')
colors <-  c ('#5588DD', '#FFFFFF', '#DD8855')
createVisualStyle(style.name, defaults, list(nodeLabels,arrowShapes,edgeWidth))
setVisualStyle(style.name)
nodes = data.frame(id = unique(nodes),col='#ff0000')
edges = data.frame(target = v[, 1], source = v[, 2], attr = v[, 3], interaction = c("interacts"), weight = 1)
createNetworkFromDataFrames(nodes, edges, title = "my first network", collection = "DataFrame Example")
Script.Name = "test.R"
rm(list = ls(all = TRUE))  # broom variables
gc()  # garbage collector
cat("\f")  #clear console
# LIBRARIES ---------------------------------------------------------------
setwd("D:/Fac/Master1/S2/Projet_annuel")
library(formatR)
library(RCy3)
formatR::tidy_file("./final.R")
p_dat = parse("./final.R")
#parse script
parsed = getParseData(p_dat)
#removing unwanted/empty/unknown lines
parsed = parsed[-c(which(parsed$token == "expr")), ]
parsed = parsed[-c(which(parsed$token %in% c("expr", "equal_assign", "forcond"))), ]
xy.list <- split(parsed, f = parsed$line1)
#extracting comments
xy.list.comments = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT")]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT") == F]
#extracting packages imports
xy.list.packages = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library")]
packages = as.character(lapply(lapply(xy.list.packages, `[[`, 9), `[[`, 3))
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library") == F]
l.packages=rep("library",length(packages))
packages=cbind(l.packages,packages)
#excluding system commands
to_remove = c("rm", "cat", "gc", "setwd")
xy.list.rm = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove)]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove) == F]
#extracting equal assign lines of length 3 (something = some other thing)
tmp_ind = which(lengths(lapply(xy.list, `[[`, 7)) == 3)
ind_eq = which(lapply(lapply(xy.list[tmp_ind], `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
eq = xy.list[tmp_ind][ind_eq]
xy.list[tmp_ind[ind_eq]] <- NULL
v = c()
for (i in 1:length(eq)) {
v = rbind(v, c(eq[[i]]$text[c(1, 3)]))
}
# v[,1]=make.unique(v[,1])
v1 = matrix(v, nrow = length(make.unique(v))/2)
v1=rbind(v1,packages)
v1 = cbind(v1, rep("", dim(v1)[1]))
##### more complex lines length > 3
tmp_ind = which(lengths(lapply(xy.list, `[[`, 7)) > 3)
## we still look at lines where there is a =
ind_eq = which(lapply(lapply(xy.list[tmp_ind], `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
eq = xy.list[tmp_ind][ind_eq]
xy.list[tmp_ind[ind_eq]] <- NULL
c=1
v2 = c()
fun = c("read.table", "readRDS")
fun2 =c("data.frame")
for (i in 1:length(eq)) {
print(eq[[i]])
if (eq[[i]]$token[3] == "SYMBOL_FUNCTION_CALL") {
#token 5: because we look after something = something else (
#                               1         2 3              4
j = which(eq[[i]]$token[5:(dim(eq[[i]])[1] - 1)] == "SYMBOL")
f = which(eq[[i]]$token[5:(dim(eq[[i]])[1] - 1)] == "SYMBOL_FUNCTION_CALL")
#specific parsing for well known functions
if (eq[[i]]$text[3]%in%fun) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste("input.file.",c,sep=""), eq[[i]]$text[3]))
c=c+1
} else if (eq[[i]]$text[3]%in%fun2) {
if (length(j) > 0 &length(f) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), paste(eq[[i]]$text[3],eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][f],sep="+")))
} else {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)],collapse=""), eq[[i]]$text[3]))}
} else if (length(j) > 0 &length(f) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), paste(eq[[i]]$text[3],eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][f],sep="+")))
} else if (length(j) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), eq[[i]]$text[3]))
} else {
v2 = rbind(v2, c(eq[[i]]$text[1], eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)], eq[[i]]$text[3]))}
} else if (eq[[i]]$text[1] == eq[[i]]$text[3]) {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
} else {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[3:(dim(eq[[i]])[1])], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
}
print(v2)
}
v = rbind(v1, v2)
nodes = as.vector(t(v))
library(RCy3)
cytoscapePing ()
cytoscapeVersionInfo ()
style.name = "myStyle"
defaults <- list(NODE_SHAPE="ellipse",
NODE_SIZE=40,
EDGE_TRANSPARENCY=120)
nodeLabels <- mapVisualProperty('node label','id','p')
nodes = as.vector(t(v))
library(RCy3)
cytoscapePing ()
cytoscapeVersionInfo ()
style.name = "myStyle"
defaults <- list(NODE_SHAPE="ellipse",
NODE_SIZE=40,
EDGE_TRANSPARENCY=120)
nodeLabels <- mapVisualProperty('node label','id','p')
Script.Name = "test.R"
rm(list = ls(all = TRUE))  # broom variables
gc()  # garbage collector
cat("\f")  #clear console
# LIBRARIES ---------------------------------------------------------------
setwd("D:/Fac/Master1/S2/Projet_annuel")
library(formatR)
library(RCy3)
formatR::tidy_file("./final.R")
p_dat = parse("./final.R")
#parse script
parsed = getParseData(p_dat)
#removing unwanted/empty/unknown lines
parsed = parsed[-c(which(parsed$token == "expr")), ]
parsed = parsed[-c(which(parsed$token %in% c("expr", "equal_assign", "forcond"))), ]
xy.list <- split(parsed, f = parsed$line1)
#extracting comments
xy.list.comments = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT")]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT") == F]
#extracting packages imports
xy.list.packages = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library")]
packages = as.character(lapply(lapply(xy.list.packages, `[[`, 9), `[[`, 3))
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library") == F]
l.packages=rep("library",length(packages))
packages=cbind(l.packages,packages)
#excluding system commands
to_remove = c("rm", "cat", "gc", "setwd")
xy.list.rm = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove)]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove) == F]
#extracting equal assign lines of length 3 (something = some other thing)
tmp_ind = which(lengths(lapply(xy.list, `[[`, 7)) == 3)
ind_eq = which(lapply(lapply(xy.list[tmp_ind], `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
eq = xy.list[tmp_ind][ind_eq]
xy.list[tmp_ind[ind_eq]] <- NULL
v = c()
for (i in 1:length(eq)) {
v = rbind(v, c(eq[[i]]$text[c(1, 3)]))
}
# v[,1]=make.unique(v[,1])
v1 = matrix(v, nrow = length(make.unique(v))/2)
v1=rbind(v1,packages)
v1 = cbind(v1, rep("", dim(v1)[1]))
##### more complex lines length > 3
tmp_ind = which(lengths(lapply(xy.list, `[[`, 7)) > 3)
## we still look at lines where there is a =
ind_eq = which(lapply(lapply(xy.list[tmp_ind], `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
eq = xy.list[tmp_ind][ind_eq]
xy.list[tmp_ind[ind_eq]] <- NULL
c=1
v2 = c()
fun = c("read.table", "readRDS")
fun2 =c("data.frame")
for (i in 1:length(eq)) {
print(eq[[i]])
if (eq[[i]]$token[3] == "SYMBOL_FUNCTION_CALL") {
#token 5: because we look after something = something else (
#                               1         2 3              4
j = which(eq[[i]]$token[5:(dim(eq[[i]])[1] - 1)] == "SYMBOL")
f = which(eq[[i]]$token[5:(dim(eq[[i]])[1] - 1)] == "SYMBOL_FUNCTION_CALL")
#specific parsing for well known functions
if (eq[[i]]$text[3]%in%fun) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste("input.file.",c,sep=""), eq[[i]]$text[3]))
c=c+1
} else if (eq[[i]]$text[3]%in%fun2) {
if (length(j) > 0 &length(f) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), paste(eq[[i]]$text[3],eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][f],sep="+")))
} else {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)],collapse=""), eq[[i]]$text[3]))}
} else if (length(j) > 0 &length(f) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), paste(eq[[i]]$text[3],eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][f],sep="+")))
} else if (length(j) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), eq[[i]]$text[3]))
} else {
v2 = rbind(v2, c(eq[[i]]$text[1], eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)], eq[[i]]$text[3]))}
} else if (eq[[i]]$text[1] == eq[[i]]$text[3]) {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
} else {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[3:(dim(eq[[i]])[1])], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
}
print(v2)
}
v = rbind(v1, v2)
nodes = as.vector(t(v))
library(RCy3)
cytoscapePing ()
cytoscapeVersionInfo ()
style.name = "myStyle"
defaults <- list(NODE_SHAPE="ellipse",
NODE_SIZE=40,
EDGE_TRANSPARENCY=120)
nodeLabels <- mapVisualProperty('node label','id','p')
nodes = as.vector(t(v))
library(RCy3)
cytoscapePing ()
cytoscapeVersionInfo ()
style.name = "myStyle"
defaults <- list(NODE_SHAPE="ellipse",
NODE_SIZE=30,
EDGE_TRANSPARENCY=120)
nodeLabels <- mapVisualProperty('node label','id','p')
Script.Name = "test.R"
rm(list = ls(all = TRUE))  # broom variables
gc()  # garbage collector
cat("\f")  #clear console
# LIBRARIES ---------------------------------------------------------------
setwd("D:/Fac/Master1/S2/Projet_annuel")
library(formatR)
library(RCy3)
formatR::tidy_file("./final.R")
p_dat = parse("./final.R")
#parse script
parsed = getParseData(p_dat)
#removing unwanted/empty/unknown lines
parsed = parsed[-c(which(parsed$token == "expr")), ]
parsed = parsed[-c(which(parsed$token %in% c("expr", "equal_assign", "forcond"))), ]
xy.list <- split(parsed, f = parsed$line1)
#extracting comments
xy.list.comments = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT")]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT") == F]
#extracting packages imports
xy.list.packages = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library")]
packages = as.character(lapply(lapply(xy.list.packages, `[[`, 9), `[[`, 3))
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library") == F]
l.packages=rep("library",length(packages))
packages=cbind(l.packages,packages)
#excluding system commands
to_remove = c("rm", "cat", "gc", "setwd")
xy.list.rm = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove)]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove) == F]
#extracting equal assign lines of length 3 (something = some other thing)
tmp_ind = which(lengths(lapply(xy.list, `[[`, 7)) == 3)
ind_eq = which(lapply(lapply(xy.list[tmp_ind], `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
eq = xy.list[tmp_ind][ind_eq]
xy.list[tmp_ind[ind_eq]] <- NULL
v = c()
for (i in 1:length(eq)) {
v = rbind(v, c(eq[[i]]$text[c(1, 3)]))
}
# v[,1]=make.unique(v[,1])
v1 = matrix(v, nrow = length(make.unique(v))/2)
v1=rbind(v1,packages)
v1 = cbind(v1, rep("", dim(v1)[1]))
##### more complex lines length > 3
tmp_ind = which(lengths(lapply(xy.list, `[[`, 7)) > 3)
## we still look at lines where there is a =
ind_eq = which(lapply(lapply(xy.list[tmp_ind], `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
eq = xy.list[tmp_ind][ind_eq]
xy.list[tmp_ind[ind_eq]] <- NULL
c=1
v2 = c()
fun = c("read.table", "readRDS")
fun2 =c("data.frame")
for (i in 1:length(eq)) {
print(eq[[i]])
if (eq[[i]]$token[3] == "SYMBOL_FUNCTION_CALL") {
#token 5: because we look after something = something else (
#                               1         2 3              4
j = which(eq[[i]]$token[5:(dim(eq[[i]])[1] - 1)] == "SYMBOL")
f = which(eq[[i]]$token[5:(dim(eq[[i]])[1] - 1)] == "SYMBOL_FUNCTION_CALL")
#specific parsing for well known functions
if (eq[[i]]$text[3]%in%fun) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste("input.file.",c,sep=""), eq[[i]]$text[3]))
c=c+1
} else if (eq[[i]]$text[3]%in%fun2) {
if (length(j) > 0 &length(f) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), paste(eq[[i]]$text[3],eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][f],sep="+")))
} else {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)],collapse=""), eq[[i]]$text[3]))}
} else if (length(j) > 0 &length(f) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), paste(eq[[i]]$text[3],eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][f],sep="+")))
} else if (length(j) > 0 ) {
v2 = rbind(v2, c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)][j],collapse="+"), eq[[i]]$text[3]))
} else {
v2 = rbind(v2, c(eq[[i]]$text[1], eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)], eq[[i]]$text[3]))}
} else if (eq[[i]]$text[1] == eq[[i]]$text[3]) {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[5:(dim(eq[[i]])[1] - 1)], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
} else {
newline=c(eq[[i]]$text[1], paste(eq[[i]]$text[3:(dim(eq[[i]])[1])], collapse = ""), "")
if (length(grep("^[,]c|^[,][-]c|^c[(]|^[-]c[(]",newline[2],perl = T))>0) {newline=newline[c(1,1,2)]}
v2 = rbind(v2,newline)
}
print(v2)
}
v = rbind(v1, v2)
nodes = as.vector(t(v))
library(RCy3)
cytoscapePing ()
cytoscapeVersionInfo ()
style.name = "myStyle"
defaults <- list(NODE_SHAPE="ellipse",
NODE_SIZE=30,
EDGE_TRANSPARENCY=120)
nodeLabels <- mapVisualProperty('node label','id','p')
arrowShapes <- mapVisualProperty('Edge Target Arrow Shape','interaction','d',c("activates","inhibits","interacts"),c("Arrow","T","None"))
edgeWidth <- mapVisualProperty('edge width','weight','p')
createVisualStyle(style.name, defaults, list(nodeLabels,arrowShapes,edgeWidth))
setVisualStyle(style.name)
#take the access path of the script to treat
simpleAssignation <- function(script) {
library(formatR)
library(RCy3)
script = "test.R"
formatR::tidy_file(script)
p_data = parse(script)
#parse script
parsed = getParseData(p_data)
#removing unwanted/empty/unknown lines
parsed = parsed[-c(which(parsed$token %in% c("expr", "equal_assign", "forcond"))), ]
xy.list <- split(parsed, f = parsed$line1)
#extracting comments
xy.list.comments = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT")]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "COMMENT") == F]
#extracting packages imports
xy.list.packages = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library")]
packages = as.character(lapply(lapply(xy.list.packages, `[[`, 9), `[[`, 3))
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) == "library") == F]
l.packages=rep("library",length(packages))
packages=cbind(l.packages,packages)
#excluding system commands
to_remove = c("rm", "cat", "gc", "setwd")
xy.list.sc = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove)]
xy.list = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 9), `[[`, 1) %in% to_remove) == F]
#assignation of variable with a operation or a direct attribution
ind_eq = xy.list[as.logical(lapply(lapply(xy.list, `[[`, 7), `[[`, 1) == "SYMBOL")] #enlève les lignes qui commence pas par un symbol
ind_eq = ind_eq[as.logical(lapply(lapply(ind_eq, `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))]
operationAssign = ind_eq[as.logical(lapply(lapply(ind_eq, `[[`, 7), `[[`, 3) %in% c("NUM_CONST", "STR_CONST"))]
tmp_ind = match( simpleAssign, xy.list)
xy.list[tmp_ind] <- NULL
tmp_ind = which(lengths(lapply(xy.list, `[[`, 7)) == 3)
ind_eq = which(lapply(lapply(xy.list[tmp_ind], `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
simpleAssignation = xy.list[tmp_ind][ind_eq]
xy.list[tmp_ind[ind_eq]] <- NULL
simpleAssignation = c(simpleAssignation,operationAssign)
tabsimpleAssignation = c()
for (i in 1:length(operationAssign)){
l = length(simpleAssignation[[2]]$text)
tabsimpleAssignation = rbin(tabsimpleAssignation,c(simpleAssignation[[i]]$text[c(1:l)]))
}
# test = xy.list[lengths((lapply(xy.list, `[[`, 7))) > 2]
# test2 = which(lapply(lapply(test, `[[`, 7), `[[`, 2) %in% c("EQ_ASSIGN",'LEFT_ASSIGN'))
# test = test[test2]
#tab = lapply(ind_eq, `[[`, 7)
# tab2 = lapply(test, `[[`, 9)
}
